/// Axiom Build Script — Production Global Deployer
///
/// Handles:
///   1. lalrpop grammar compilation
///   2. ~/.axiom/bin/ directory creation
///   3. Binary relocation after build (release only)
///   4. PATH integration — setx (Windows) or shell profile update (Unix)
///   5. ~/.axiomlibs/ directory creation for the package manager

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    println!("cargo:rerun-if-changed=src/");
    println!("cargo:rerun-if-changed=build.rs");

    // ── 1. Run lalrpop grammar compilation ──────────────────────────────────
    if std::path::Path::new("src/parser.lalrpop").exists() {
        match lalrpop::process_root() {
            Ok(_) => {}
            Err(e) => {
                println!("cargo:warning=lalrpop: {}", e);
            }
        }
    }

    // ── 2. Create ~/.axiom directory structure ───────────────────────────────
    let axiom_home = get_axiom_home();
    let bin_dir = axiom_home.join("bin");
    let lib_dir = axiom_home.join("lib");

    ensure_dir(&axiom_home);
    ensure_dir(&bin_dir);
    ensure_dir(&lib_dir);

    // ── 3. Create ~/.axiomlibs/ (package manager store) ──────────────────────
    let axiomlibs_dir = get_axiomlibs_dir();
    ensure_dir(&axiomlibs_dir);

    // ── 3b. Write default conf.txt to ~/.axiom/conf.txt ──────────────────────
    write_default_conf(&axiom_home);

    // ── 4. Set build-time environment variables ───────────────────────────────
    println!("cargo:rustc-env=AXIOM_HOME={}", axiom_home.display());
    println!("cargo:rustc-env=AXIOM_BIN_DIR={}", bin_dir.display());
    println!("cargo:rustc-env=AXIOM_LIB_DIR={}", lib_dir.display());
    println!("cargo:rustc-env=AXIOMLIBS_DIR={}", axiomlibs_dir.display());

    // ── 5. Binary relocation and PATH integration (release only) ─────────────
    let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());
    if profile == "release" {
        deploy_binary(&bin_dir);
        ensure_path_contains(&bin_dir);

        println!("cargo:warning=╔══════════════════════════════════════════╗");
        println!("cargo:warning=║        Axiom Apex Build Complete         ║");
        println!("cargo:warning=╚══════════════════════════════════════════╝");
        println!("cargo:warning=Binary  → {}/axm", bin_dir.display());
        println!("cargo:warning=Libs    → {}", axiomlibs_dir.display());
        println!("cargo:warning=Home    → {}", axiom_home.display());
    }
}

fn get_axiom_home() -> PathBuf {
    if let Ok(override_home) = env::var("AXIOM_HOME") {
        return PathBuf::from(override_home);
    }
    #[cfg(target_os = "windows")]
    {
        if let Ok(userprofile) = env::var("USERPROFILE") {
            return PathBuf::from(userprofile).join(".axiom");
        }
        if let Ok(local) = env::var("LOCALAPPDATA") {
            return PathBuf::from(local).join("axiom");
        }
    }
    if let Ok(home) = env::var("HOME") {
        return PathBuf::from(home).join(".axiom");
    }
    PathBuf::from(".axiom")
}

fn get_axiomlibs_dir() -> PathBuf {
    if let Ok(custom) = env::var("AXIOM_LIBS") {
        return PathBuf::from(custom);
    }
    #[cfg(target_os = "windows")]
    {
        if let Ok(userprofile) = env::var("USERPROFILE") {
            return PathBuf::from(userprofile).join(".axiomlibs");
        }
    }
    if let Ok(home) = env::var("HOME") {
        return PathBuf::from(home).join(".axiomlibs");
    }
    PathBuf::from(".axiomlibs")
}

/// Write (or refresh) the default conf.txt at ~/.axiom/conf.txt.
/// Uses std::env::var("HOME") / "USERPROFILE" for cross-platform compatibility.
/// Only writes if the file does not already exist, preserving user customisations.
fn write_default_conf(axiom_home: &Path) {
    let conf_path = axiom_home.join("conf.txt");
    if conf_path.exists() {
        // Never overwrite user-modified config — only seed on first install.
        return;
    }

    let contents = r#"# Axiom Configuration — ~/.axiom/conf.txt
# Generated by `cargo build` on first install.
# Edit manually or use: axm conf set property=value
# Reset to defaults:   axm conf reset

# ── Feature Toggles (master switches) ─────────────────────────────
nan_boxing=true
bytecode_format=true
ic_enabled=true
gc_enabled=true
peephole_optimizer=true
profiling_enabled=true

# ── Debug ─────────────────────────────────────────────────────────
debug=off
opcode_trace=off
gc_verbose=off
bounds_check=on
stack_trace_on_error=on

# ── Inline Caching ────────────────────────────────────────────────
inline_cache=on
poly_ic_size=4
call_ic=on

# ── Garbage Collector ─────────────────────────────────────────────
gc_mode=generational
nursery_size_kb=2048
gc_parallel=off

# ── Optimization ──────────────────────────────────────────────────
constant_folding=on
peephole=on
dead_code=on
jump_threading=on
superinstructions=on
opt_level=2

# ── Type Specialization ───────────────────────────────────────────
quickening=on
shape_optimization=on
deopt_on_type_change=on
quicken_threshold=16

# ── Profiling ─────────────────────────────────────────────────────
profiling=off
opcode_counters=on
hot_loop_detect=on
hot_threshold=100
flame_graph=off
alloc_tracking=off

# ── Parallelism ───────────────────────────────────────────────────
parallel_gc=off
simd=off
thread_pool_size=0

# ── Experimental / JIT ────────────────────────────────────────────
jit=off
trace_formation=off
aot_specialization=off

# ── Allocator ─────────────────────────────────────────────────────
allocator=bump
string_interning=on

# ── Bytecode ──────────────────────────────────────────────────────
bytecode_compression=off
bytecode_cache=off

# ── VM ────────────────────────────────────────────────────────────
max_call_depth=500
register_count=256
"#;

    match fs::write(&conf_path, contents) {
        Ok(_) => println!("cargo:warning=Default conf.txt written to {}", conf_path.display()),
        Err(e) => println!("cargo:warning=Could not write conf.txt to {}: {}", conf_path.display(), e),
    }
}

fn ensure_dir(path: &Path) {
    if !path.exists() {
        match fs::create_dir_all(path) {
            Ok(_) => println!("cargo:warning=Created: {}", path.display()),
            Err(e) => println!("cargo:warning=Could not create {}: {}", path.display(), e),
        }
    }
}

fn deploy_binary(bin_dir: &Path) {
    let out_dir = match env::var("OUT_DIR") {
        Ok(d) => PathBuf::from(d),
        Err(_) => return,
    };

    let binary_name = if cfg!(target_os = "windows") { "axm.exe" } else { "axm" };
    let mut candidate = out_dir.as_path();

    for _ in 0..8 {
        let bin_path = candidate.join(binary_name);
        if bin_path.exists() {
            let dest = bin_dir.join(binary_name);
            match fs::copy(&bin_path, &dest) {
                Ok(_) => {
                    println!("cargo:warning=Deployed {} → {}", bin_path.display(), dest.display());
                    #[cfg(unix)]
                    {
                        use std::os::unix::fs::PermissionsExt;
                        if let Ok(meta) = fs::metadata(&dest) {
                            let mut perms = meta.permissions();
                            perms.set_mode(0o755);
                            let _ = fs::set_permissions(&dest, perms);
                        }
                    }
                }
                Err(e) => println!("cargo:warning=Binary copy failed: {}", e),
            }
            return;
        }
        candidate = match candidate.parent() {
            Some(p) => p,
            None => break,
        };
    }
    println!("cargo:warning=Note: run `cargo install --path .` for global axm install");
}

fn ensure_path_contains(bin_dir: &Path) {
    let bin_str = bin_dir.to_string_lossy().to_string();
    let current_path = env::var("PATH").unwrap_or_default();
    let sep = if cfg!(target_os = "windows") { ';' } else { ':' };

    if current_path.split(sep).any(|p| p == bin_str) {
        return;
    }

    #[cfg(target_os = "windows")]
    add_to_path_windows(&bin_str);

    #[cfg(not(target_os = "windows"))]
    add_to_path_unix(bin_dir);
}

#[cfg(target_os = "windows")]
fn add_to_path_windows(bin_str: &str) {
    use std::process::Command;
    let current = env::var("PATH").unwrap_or_default();
    let new_path = format!("{};{}", current, bin_str);
    let output = Command::new("setx").args(&["PATH", &new_path]).output();
    match output {
        Ok(o) if o.status.success() => println!("cargo:warning=PATH updated via setx"),
        Ok(o) => println!("cargo:warning=setx stderr: {}", String::from_utf8_lossy(&o.stderr)),
        Err(e) => println!("cargo:warning=Could not run setx: {}", e),
    }
}

#[cfg(not(target_os = "windows"))]
fn add_to_path_unix(bin_dir: &Path) {
    let bin_str = bin_dir.to_string_lossy();
    let home = match env::var("HOME") {
        Ok(h) => PathBuf::from(h),
        Err(_) => return,
    };

    let profiles = [
        ".bashrc",
        ".bash_profile",
        ".zshrc",
        ".profile",
    ];

    for profile_name in &profiles {
        let profile_path = home.join(profile_name);
        if !profile_path.exists() { continue; }

        let existing = fs::read_to_string(&profile_path).unwrap_or_default();
        if existing.contains(bin_str.as_ref()) { continue; }

        let export_line = format!(
            "\n# Added by axm build — Axiom Language Toolchain\nexport PATH=\"{}:$PATH\"\n",
            bin_str
        );

        use std::io::Write;
        if let Ok(mut file) = fs::OpenOptions::new().append(true).open(&profile_path) {
            if file.write_all(export_line.as_bytes()).is_ok() {
                println!("cargo:warning=PATH entry added to {}", profile_path.display());
            }
        }
    }

    // Also try fish config
    let fish_config = home.join(".config/fish/config.fish");
    if fish_config.exists() {
        let existing = fs::read_to_string(&fish_config).unwrap_or_default();
        if !existing.contains(bin_str.as_ref()) {
            let fish_line = format!("\n# Added by axm build\nset -x PATH {} $PATH\n", bin_str);
            use std::io::Write;
            if let Ok(mut file) = fs::OpenOptions::new().append(true).open(&fish_config) {
                let _ = file.write_all(fish_line.as_bytes());
            }
        }
    }

    println!("cargo:warning=Restart shell or: export PATH=\"{}:$PATH\"", bin_str);
}
