use crate::ast::{Item, Stmt, Expr, ClassMember, EnumVariant, MatchArm, MatchPattern, StringPart};
use crate::errors::{Span, ParserError};
use crate::lexer::Token;

grammar(source_id: u32);

pub Program: Vec<Item> = {
    <items:Item*> => items,
};

Item: Item = {
    FunctionDecl => <>,
    ClassDecl => <>,
    EnumDecl => <>,
    StdImport => <>,
    LocImport => <>,
    LibDecl => <>,
    <s:Stmt> => Item::Statement(s),
};

/// Function declarations: "fun" keyword is now optional
/// Supports: fun name() { } or name() { }
FunctionDecl: Item = {
    "fun"? <name:Ident> "(" <params:ParamList> ")" <body:Block> => {
        Item::FunctionDecl { name, params, body, span: Default::default() }
    },
};

/// Class declarations: "cls" keyword is now optional
/// Supports: cls Name { } or Name { }
ClassDecl: Item = {
    "cls"? <name:Ident> <parent:("ext" <Ident>)?> "{" <members:ClassMember*> "}" => {
        Item::ClassDecl { name, parent, body: members, span: Default::default() }
    },
};

ClassMember: ClassMember = {
    "fun"? <name:Ident> "(" <params:ParamList> ")" <body:Block> => {
        ClassMember::Method { name, params, body, span: Default::default() }
    },
    "let" <name:Ident> <default:("=" <Expr>)?> ";" => {
        ClassMember::Field { name, default, span: Default::default() }
    },
};

/// Enum declarations: "enm" keyword is now optional
/// Supports: enm Name { } or Name { }
EnumDecl: Item = {
    "enm"? <name:Ident> "{" <variants:SepBy<EnumVariant, ",">> "}" => {
        Item::EnumDecl { name, variants, span: Default::default() }
    },
};

EnumVariant: EnumVariant = {
    <name:Ident> <has_data:("(" "...")? )> => {
        EnumVariant { name, has_data: has_data.is_some(), span: Default::default() }
    },
};

StdImport: Item = {
    "std" <name:Ident> ";" => Item::StdImport { name, span: Default::default() },
};

LocImport: Item = {
    "loc" <name:Ident> ";" => Item::LocImport { name, span: Default::default() },
};

LibDecl: Item = {
    "lib" <name:Ident> ";" => Item::LibDecl { name, span: Default::default() },
};

ParamList: Vec<String> = {
    <p:SepBy<IdentOrSelf, ",">> => p,
};

IdentOrSelf: String = {
    <i:Ident> => i,
    "self" => "self".to_string(),
};

Stmt: Stmt = {
    <e:Expr> ";" => Stmt::Expr(e),
    "let" <name:Ident> "=" <value:Expr> ";" => Stmt::Let { name, value, span: Default::default() },
    "ret" <value:Expr?> ";" => Stmt::Return { value, span: Default::default() },
    "if" <condition:Expr> <then_body:Block> <else_body:("else" <ElseBody>)?> => {
        Stmt::If { condition, then_body, else_body, span: Default::default() }
    },
    "while" <condition:Expr> <body:Block> => Stmt::While { condition, body, span: Default::default() },
    "for" <var:Ident> "in" <iterable:Expr> <body:Block> => Stmt::For { var, iterable, body, span: Default::default() },
    "go" <body:Block> => Stmt::GoSpawn { body, span: Default::default() },
    "match" <expr:Expr> "{" <arms:MatchArm*> "}" => Stmt::Match { expr, arms, span: Default::default() },
    "out" <arguments:SepBy<Expr, ",">> ";" => Stmt::Out { arguments, span: Default::default() },
    Block => Stmt::Block(<>),
};

ElseBody: Vec<Stmt> = {
    Block => <>,
    <i:Stmt> => vec![i],
};

Block: Vec<Stmt> = {
    "{" <s:Stmt*> "}" => s,
};

MatchArm: MatchArm = {
    <pattern:MatchPattern> "=>" <body:MatchBody> ","? => {
        MatchArm { pattern, body, span: Default::default() }
    },
};

MatchBody: Vec<Stmt> = {
    Block => <>,
    <e:Expr> => vec![Stmt::Expr(e)],
};

/// CleanMatch Syntax
/// Supports: "_" or "els" for wildcards
/// Supports: "name" for identifiers or "EnumName:Variant" for enum variants
MatchPattern: MatchPattern = {
    "_" => MatchPattern::Wildcard,
    "els" => MatchPattern::Wildcard,
    <i:Ident> => MatchPattern::Identifier(i),
    <e:Expr> => MatchPattern::Literal(e),
    <enum_name:Ident> ":" <variant:Ident> "(" <binding:Ident?> ")" => {
        MatchPattern::EnumVariant { enum_name: Some(enum_name), variant, binding }
    },
    <variant:Ident> "(" <binding:Ident?> ")" => {
        MatchPattern::EnumVariant { enum_name: None, variant, binding }
    },
    "." <variant:Ident> => {
        MatchPattern::EnumVariant { enum_name: None, variant, binding: None }
    },
};

Expr: Expr = {
    Assignment => <>,
};

Assignment: Expr = {
    <target:LogicalOr> "=" <value:Assignment> => {
        Expr::Assign { target: Box::new(target), value: Box::new(value), span: Default::default() }
    },
    LogicalOr => <>,
};

LogicalOr: Expr = {
    <l:LogicalOr> "||" <r:LogicalAnd> => {
        Expr::BinaryOp { left: Box::new(l), op: "||".to_string(), right: Box::new(r), span: Default::default() }
    },
    LogicalAnd => <>,
};

LogicalAnd: Expr = {
    <l:LogicalAnd> "&&" <r:Equality> => {
        Expr::BinaryOp { left: Box::new(l), op: "&&".to_string(), right: Box::new(r), span: Default::default() }
    },
    Equality => <>,
};

Equality: Expr = {
    <l:Equality> <op:EqualityOp> <r:Comparison> => {
        Expr::BinaryOp { left: Box::new(l), op: op.to_string(), right: Box::new(r), span: Default::default() }
    },
    Comparison => <>,
};

EqualityOp: String = {
    "==" => "==".to_string(),
    "!=" => "!=".to_string(),
};

Comparison: Expr = {
    <l:Comparison> <op:ComparisonOp> <r:Term> => {
        Expr::BinaryOp { left: Box::new(l), op: op.to_string(), right: Box::new(r), span: Default::default() }
    },
    Term => <>,
};

ComparisonOp: String = {
    "<" => "<".to_string(),
    "<=" => "<=".to_string(),
    ">" => ">".to_string(),
    ">=" => ">=".to_string(),
};

Term: Expr = {
    <l:Term> <op:TermOp> <r:Factor> => {
        Expr::BinaryOp { left: Box::new(l), op: op.to_string(), right: Box::new(r), span: Default::default() }
    },
    Factor => <>,
};

TermOp: String = {
    "+" => "+".to_string(),
    "-" => "-".to_string(),
};

Factor: Expr = {
    <l:Factor> <op:FactorOp> <r:Unary> => {
        Expr::BinaryOp { left: Box::new(l), op: op.to_string(), right: Box::new(r), span: Default::default() }
    },
    Unary => <>,
};

FactorOp: String = {
    "*" => "*".to_string(),
    "/" => "/".to_string(),
    "%" => "%".to_string(),
};

Unary: Expr = {
    "!" <e:Unary> => Expr::UnaryOp { op: "!".to_string(), operand: Box::new(e), span: Default::default() },
    "-" <e:Unary> => Expr::UnaryOp { op: "-".to_string(), operand: Box::new(e), span: Default::default() },
    Call => <>,
};

Call: Expr = {
    <f:Call> "(" <args:SepBy<Expr, ",">> ")" => {
        Expr::Call { function: Box::new(f), arguments: args, span: Default::default() }
    },
    <o:Call> "." <m:Ident> "(" <args:SepBy<Expr, ",">> ")" => {
        Expr::MethodCall { object: Box::new(o), method: m, arguments: args, span: Default::default() }
    },
    <o:Call> "." <m:Ident> => {
        Expr::MemberAccess { object: Box::new(o), member: m, span: Default::default() }
    },
    <o:Call> "[" <i:Expr> "]" => {
        Expr::Index { object: Box::new(o), index: Box::new(i), span: Default::default() }
    },
    Primary => <>,
};

Primary: Expr = {
    <n:Num> => Expr::Number { value: n, span: Default::default() },
    <s:Str> => Expr::String { value: s, span: Default::default() },
    <b:Bool> => Expr::Boolean { value: b, span: Default::default() },
    <i:Ident> => Expr::Identifier { name: i, span: Default::default() },
    /* Allow "out" and "in" identifiers so calls like out("...") and in() parse */
    "out" => Expr::Identifier { name: "out".to_string(), span: Default::default() },
    "in"  => Expr::Identifier { name: "in".to_string(), span: Default::default() },
    "self" => Expr::SelfRef { span: Default::default() },
    "." => Expr::SelfRef { span: Default::default() },
    "new" <name:Ident> "(" <args:SepBy<Expr, ",">> ")" => {
        Expr::New { class_name: name, arguments: args, span: Default::default() }
    },
    "[" <items:SepBy<Expr, ",">> "]" => Expr::List { items, span: Default::default() },
    "(" <e:Expr> ")" => e,
    <p:InterpolatedString> => Expr::InterpolatedString { parts: p, span: Default::default() },
    "(" <params:SepBy<Ident, ",">> ")" "=>" <body:Expr> => {
        Expr::Lambda { params, body: Box::new(body), span: Default::default() }
    },
};

// Externals / Macros
SepBy<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v.into_iter().map(|(t, _)| t).collect(),
        Some(e) => {
            let mut v: Vec<T> = v.into_iter().map(|(t, _)| t).collect();
            v.push(e);
            v
        }
    }
};

extern {
    type Location = usize;
    type Error = ParserError;

    enum Token {
        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,
        "for" => Token::For,
        "in" => Token::In,
        "fun" => Token::Fun,
        "ret" => Token::Return,
        "let" => Token::Let,
        "go" => Token::Go,
        "std" => Token::Std,
        "loc" => Token::Loc,
        "lib" => Token::Lib,
        "cls" => Token::Cls,
        "ext" => Token::Ext,
        "enm" => Token::Enm,
        "self" => Token::SelfKw,
        "out" => Token::Out,
        "new" => Token::New,
        "match" => Token::Match,
        "els" => Token::Els,
        Num => Token::Number(<f64>),
        Str => Token::String(<String>),
        InterpolatedString => Token::InterpolatedString(<Vec<(bool, String)>>),
        Bool => Token::True | Token::False,
        Ident => Token::Ident(<String>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "&&" => Token::And,
        "||" => Token::Or,
        "!" => Token::Not,
        "=" => Token::Assign,
        "lp" => Token::LParen,
        "rp" => Token::RParen,
        "lb" => Token::LBrace,
        "rb" => Token::RBrace,
        "lbr" => Token::LBracket,
        "rbr" => Token::RBracket,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "." => Token::Dot,
        "=>" => Token::Arrow,
    }
}
